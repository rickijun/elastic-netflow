input {
  udp {
    port => 2055
    codec => netflow {
      versions => [5,9,10]
    }
    type => netflow
  }
}



filter {
  #####################################################################
  # 1. Enrich with Application Name (based on port)
  #####################################################################

  # Convert ports to integer safely
  if [netflow][l4_dst_port] {
    mutate { convert => { "[netflow][l4_dst_port]" => "integer" } }
  }
  if [netflow][l4_src_port] {
    mutate { convert => { "[netflow][l4_src_port]" => "integer" } }
  }

  # Normalize app_port safely
  if [netflow][l4_dst_port] and [netflow][l4_dst_port] < 1024 {
    mutate { add_field => { "app_port" => "%{[netflow][l4_dst_port]}" } }
  } else if [netflow][l4_src_port] and [netflow][l4_src_port] < 1024 {
    mutate { add_field => { "app_port" => "%{[netflow][l4_src_port]}" } }
  } else if [netflow][l4_dst_port] {
    mutate { add_field => { "app_port" => "%{[netflow][l4_dst_port]}" } }
  }

  mutate { convert => { "app_port" => "string" } }


  # Now translate application name
  translate {
    field       => "app_port"
    destination => "protocol_name"
    dictionary => {
      "80"   => "HTTP"
      "443"  => "HTTPS"
      "22"   => "SSH"
      "53"   => "DNS"
      "25"   => "SMTP"
      "110"  => "POP3"
      "143"  => "IMAP"
      "3306" => "MySQL"
      "3389" => "RDP"
    }
    fallback => "unknown"
  }


  #####################################################################
  # 2. GeoIP Enrichment (Source and Destination)
  #####################################################################

  geoip {
    source => "[netflow][ipv4_dst_addr]"
    target => "geoip_dst"
  }

  geoip {
    source => "[netflow][ipv4_src_addr]"
    target => "geoip_src"
  }



  #####################################################################
  # 3. Local Hostname Mapping (Internal IPs)
  #####################################################################
  translate {
    field           => "[netflow][ipv4_src_addr]"
    destination     => "src_hostname"
    dictionary_path => "/etc/logstash/local_hosts.csv"
    refresh_interval => 300
    fallback        => "%{[netflow][ipv4_src_addr]}"
  }

  translate {
    field           => "[netflow][ipv4_dst_addr]"
    destination     => "dst_hostname"
    dictionary_path => "/etc/logstash/local_hosts.csv"
    refresh_interval => 300
    fallback        => "%{[netflow][ipv4_dst_addr]}"
  }

  #####################################################################
  # 4. Reverse DNS for External IPs
  #####################################################################
  dns {
    reverse => "[netflow][ipv4_src_addr]"
    action  => "replace"
    add_tag => [ "dns_resolved" ]
    nameserver => ["8.8.8.8", "1.1.1.1"]
  }

  dns {
    reverse => "[netflow][ipv4_dst_addr]"
    action  => "replace"
    add_tag => [ "dns_resolved" ]
    nameserver => ["8.8.8.8", "1.1.1.1"]
  }
}


#########################################################################




output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "netflow-%{+YYYY.MM.dd}"
    user => "elastic"
    password => "elastic-password"
  }

    # Debug to console (comment out in production)
  stdout {
    codec => rubydebug
  }  
}


